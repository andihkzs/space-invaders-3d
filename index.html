<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Space Invaders 3D</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden;
            touch-action: none; /* Prevent default touch behaviors */
            user-select: none; /* Prevent text selection */
        } 
        canvas { 
            display: block; 
            width: 100vw;
            height: 100vh;
        }
        
        /* Mobile Controls */
        .mobile-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none; /* Hidden by default, shown on mobile */
            z-index: 1000;
        }
        
        /* Touch area indicator */
        .touch-area {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 60%;
            background: transparent; /* Invisible background */
            border: none; /* No border */
            display: none;
            z-index: 999;
            pointer-events: auto; /* Allow touch events */
        }
        
        .touch-area.active {
            display: block;
        }
        
        /* Touch area instructions */
        .touch-instructions {
            position: fixed;
            top: 80px; /* Position under the logo */
            left: 10px;
            color: #00ff00;
            font-size: 16px;
            text-align: left;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            border: 1px solid #00ff00;
            display: none;
            z-index: 1001;
        }
        
        .control-pad {
            display: flex;
            gap: 20px;
            align-items: center;
        }
        
        .direction-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .direction-row {
            display: flex;
            gap: 10px;
        }
        
        .control-btn {
            width: 60px;
            height: 60px;
            border: 3px solid #00ff00;
            background: rgba(0, 255, 0, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #00ff00;
            cursor: pointer;
            user-select: none;
            transition: all 0.2s ease;
        }
        
        .control-btn:active,
        .control-btn.active {
            background: rgba(0, 255, 0, 0.5);
            transform: scale(0.95);
        }
        
        .fire-btn {
            width: 80px;
            height: 80px;
            border: 4px solid #ff0000;
            background: rgba(255, 0, 0, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            color: #ff0000;
            cursor: pointer;
            user-select: none;
            transition: all 0.2s ease;
        }
        
        .fire-btn:active,
        .fire-btn.active {
            background: rgba(255, 0, 0, 0.6);
            transform: scale(0.9);
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            .mobile-controls {
                display: none; /* Hide buttons, use finger controls */
            }
            
            .touch-area {
                display: block;
            }
            
            .touch-instructions {
                display: block;
            }
            
            .controlsElement {
                display: none !important; /* Hide desktop controls on mobile */
            }
            
            /* Adjust UI elements for mobile */
            #scoreElement {
                font-size: 18px !important;
                top: 5px !important;
                right: 10px !important;
                left: auto !important;
            }
            
            #highScoreElement {
                font-size: 16px !important;
                top: 30px !important;
                right: 10px !important;
            }
            
            #logoElement {
                font-size: 18px !important;
                top: 5px !important;
                left: 10px !important;
            }
            
            .touch-instructions {
                top: 70px !important;
                left: 10px !important;
                font-size: 14px !important;
            }
            
            .controlsElement {
                top: 120px !important;
                left: 10px !important;
                font-size: 12px !important;
            }
        }
        
        /* Landscape orientation adjustments */
        @media (max-width: 768px) and (orientation: landscape) {
            .mobile-controls {
                bottom: 10px;
            }
            
            .control-btn {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
            
            .fire-btn {
                width: 70px;
                height: 70px;
                font-size: 28px;
            }
        }
        
        /* Enhanced logo animations */
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
    </style>
</head>
<body>
    <!-- Touch Area for Finger Controls -->
    <div class="touch-area" id="touchArea"></div>
    
    <!-- Touch Instructions -->
    <div class="touch-instructions" id="touchInstructions">
        üëÜ Touch & drag to move ‚Ä¢ Hold to auto-fire
    </div>
    
    <!-- Mobile Controls (Fallback) -->
    <div class="mobile-controls">
        <div class="control-pad">
            <div class="direction-controls">
                <div class="direction-row">
                    <div class="control-btn" id="leftBtn">‚Üê</div>
                    <div class="control-btn" id="rightBtn">‚Üí</div>
                </div>
            </div>
            <div class="fire-btn" id="fireBtn">üî•</div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script> <!-- Three.js library -->
    <script>
        // Global variables
let scene, camera, renderer;
let keys = {}; // Track pressed keys
let projectiles = []; // Array for lasers
let ship; // Player ship
let invaders = []; // Array of invaders
let score = 0;
let gameOver = false;
let wave = 1;
let highScore = localStorage.getItem('spaceInvadersHighScore') || 0;
let stars = []; // Array for star animation

// SpaceX rocket variables
let spaceXRockets = []; // Array for SpaceX rockets
let rocketSpawnTimer = 0;
let rocketSpawnInterval = 300; // Frames between potential spawns
let rocketSpawnChance = 0.02; // 2% chance per check

// Touch control variables
let isTouching = false;
let touchStartX = 0;
let touchStartY = 0;
let lastTouchX = 0;
let lastTouchY = 0;
let touchMoveThreshold = 10; // Minimum distance for movement
let autoFireInterval = null;
let autoFireRate = 300; // Milliseconds between auto-fire shots

// Audio context for sound effects
let audioContext;
let shootSound;
const scoreElement = document.createElement('div'); // HTML overlay for score
scoreElement.id = 'scoreElement';
scoreElement.style.position = 'absolute';
scoreElement.style.top = '10px';
scoreElement.style.right = '10px'; // Moved to top right
scoreElement.style.color = 'white';
scoreElement.style.fontSize = '24px';
scoreElement.style.fontWeight = 'bold';
scoreElement.style.textAlign = 'right';
document.body.appendChild(scoreElement);

const gameOverElement = document.createElement('div'); // Game Over overlay
gameOverElement.style.position = 'absolute';
gameOverElement.style.top = '50%';
gameOverElement.style.left = '50%';
gameOverElement.style.transform = 'translate(-50%, -50%)';
gameOverElement.style.color = 'red';
gameOverElement.style.fontSize = '48px';
gameOverElement.style.fontWeight = 'bold';
gameOverElement.style.textAlign = 'center';
gameOverElement.style.display = 'none';
gameOverElement.style.zIndex = '10000'; // Ensure it's above everything
gameOverElement.style.backgroundColor = 'rgba(0, 0, 0, 0.9)'; // Dark background
gameOverElement.style.padding = '20px';
gameOverElement.style.borderRadius = '10px';
gameOverElement.style.border = '2px solid red';
document.body.appendChild(gameOverElement);

const highScoreElement = document.createElement('div'); // High Score display
highScoreElement.id = 'highScoreElement';
highScoreElement.style.position = 'absolute';
highScoreElement.style.top = '40px';
highScoreElement.style.right = '10px';
highScoreElement.style.color = 'yellow';
highScoreElement.style.fontSize = '20px';
highScoreElement.style.fontWeight = 'bold';
highScoreElement.style.textAlign = 'right';
highScoreElement.textContent = `High Score: ${highScore}`;
document.body.appendChild(highScoreElement);

        // ZHONG GAMES Logo - Enhanced with spaceship theme
const logoElement = document.createElement('div');
logoElement.id = 'logoElement';
logoElement.style.position = 'absolute';
logoElement.style.top = '10px';
logoElement.style.left = '10px';
logoElement.style.color = '#00ff00';
logoElement.style.fontSize = '24px';
logoElement.style.fontWeight = 'bold';
logoElement.style.fontFamily = 'Arial, sans-serif';
logoElement.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
logoElement.style.background = 'linear-gradient(45deg, #00ff00, #008800)';
logoElement.style.webkitBackgroundClip = 'text';
logoElement.style.webkitTextFillColor = 'transparent';
logoElement.style.backgroundClip = 'text';
logoElement.style.padding = '5px 10px';
logoElement.style.border = '2px solid #00ff00';
logoElement.style.borderRadius = '8px';
logoElement.style.backgroundColor = 'rgba(0,0,0,0.7)';
logoElement.style.boxShadow = '0 0 10px rgba(0,255,0,0.3)';
logoElement.innerHTML = `
    <div style="display: flex; align-items: center; gap: 8px;">
        <span style="font-size: 28px; animation: pulse 2s infinite;">üöÄ</span>
        <div>
            <div style="font-size: 18px; color: #00ff00;">ZHONG</div>
            <div style="font-size: 14px; color: #008800;">GAMES</div>
        </div>
    </div>
`;
document.body.appendChild(logoElement);

// Controls Information Panel
const controlsElement = document.createElement('div');
controlsElement.className = 'controlsElement';
controlsElement.style.position = 'absolute';
controlsElement.style.top = '140px'; // Position under the touch instructions
controlsElement.style.left = '10px';
controlsElement.style.color = '#00ff00';
controlsElement.style.fontSize = '14px';
controlsElement.style.fontFamily = 'Arial, sans-serif';
controlsElement.style.fontWeight = 'bold';
controlsElement.style.textShadow = '1px 1px 2px rgba(0,0,0,0.8)';
controlsElement.style.background = 'rgba(0,0,0,0.7)';
controlsElement.style.padding = '10px';
controlsElement.style.borderRadius = '8px';
controlsElement.style.border = '1px solid #00ff00';
controlsElement.innerHTML = `
    <div style="margin-bottom: 5px; color: #ffffff; font-size: 16px;">üéÆ CONTROLS</div>
    <div style="display: flex; flex-direction: column; gap: 3px;">
        <div><span style="color: #00ff00;">‚Üê ‚Üí</span> Move Ship</div>
        <div><span style="color: #00ff00;">SPACE</span> Shoot Laser</div>
        <div><span style="color: #ffff00;">üéØ</span> Destroy Invaders</div>
        <div><span style="color: #ff0000;">‚ö†Ô∏è</span> Avoid Enemy Lasers</div>
    </div>
`;
document.body.appendChild(controlsElement);

// Enhanced reset game function
function resetGame() {
    console.log('resetGame() called!');
    
    // Clear all invaders
    invaders.forEach(inv => {
        scene.remove(inv);
        // Dispose of geometries and materials to prevent memory leaks
        inv.children.forEach(child => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
                if (Array.isArray(child.material)) {
                    child.material.forEach(mat => mat.dispose());
                } else {
                    child.material.dispose();
                }
            }
        });
    });
    invaders = [];
    
    // Clear all projectiles
    projectiles.forEach(proj => {
        if (proj.mesh) {
            scene.remove(proj.mesh);
            // Dispose of projectile resources
            proj.mesh.children.forEach(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });
        } else {
            scene.remove(proj);
            // Dispose of projectile resources
            proj.children.forEach(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });
        }
    });
    projectiles = [];
    
    // Clear all explosions
    explosions.forEach(explosion => {
        scene.remove(explosion);
        explosion.children.forEach(child => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
        });
    });
    explosions = [];
    
    // Clear all SpaceX rockets
    spaceXRockets.forEach(rocket => {
        scene.remove(rocket);
        rocket.children.forEach(child => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
                if (Array.isArray(child.material)) {
                    child.material.forEach(mat => mat.dispose());
                } else {
                    child.material.dispose();
                }
            }
        });
    });
    spaceXRockets = [];
    
    // Reset SpaceX rocket timers
    rocketSpawnTimer = 0;
    rocketSpawnInterval = 300;
    
    // Reset game state
    score = 0;
    gameOver = false;
    wave = 1;
    
    // Stop any ongoing auto-fire
    stopAutoFire();
    isTouching = false;
    
    // Update displays
    scoreElement.innerText = `Score: ${score}`;
    gameOverElement.style.display = 'none';
    console.log('Game over element hidden');
    
    // Show touch area again when game restarts
    const touchArea = document.querySelector('.touch-area');
    if (touchArea && isMobile()) {
        touchArea.style.display = 'block';
        console.log('Touch area shown for mobile');
    }
    
    // Create new enhanced wave of invaders
    console.log('Creating new enhanced wave of invaders...');
    for (let row = 0; row < 3; row++) {
        for (let col = 0; col < 5; col++) {
            const invaderGroup = new THREE.Group();
            
            // Different invader types per row
            if (row === 0) {
                // Elite invaders
                const invaderGeometry = new THREE.OctahedronGeometry(1.8, 1);
                const invaderMaterial = new THREE.MeshPhysicalMaterial({ 
                    color: 0xff6600,
                    metalness: 0.9,
                    roughness: 0.1,
                    emissive: 0x331100,
                    emissiveIntensity: 0.8,
                    transparent: true,
                    opacity: 0.95
                });
                const invader = new THREE.Mesh(invaderGeometry, invaderMaterial);
                invader.castShadow = true;
                invader.receiveShadow = true;
                invaderGroup.add(invader);
                
                const ringGeometry = new THREE.RingGeometry(2, 2.5, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff3300,
                    transparent: true,
                    opacity: 0.6,
                    emissive: 0xff3300,
                    emissiveIntensity: 0.4,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI / 2;
                invaderGroup.add(ring);
                invaderGroup.userData = { ring, type: 'elite' };
                
            } else if (row === 1) {
                // Standard invaders
                const invaderGeometry = new THREE.IcosahedronGeometry(1.6, 0);
                const invaderMaterial = new THREE.MeshPhysicalMaterial({ 
                    color: 0xffff00,
                    metalness: 0.6,
                    roughness: 0.3,
                    emissive: 0x444400,
                    emissiveIntensity: 0.6,
                    transparent: true,
                    opacity: 0.9
                });
                const invader = new THREE.Mesh(invaderGeometry, invaderMaterial);
                invader.castShadow = true;
                invader.receiveShadow = true;
                invaderGroup.add(invader);
                invaderGroup.userData = { type: 'standard' };
                
            } else {
                // Scout invaders
                const invaderGeometry = new THREE.TetrahedronGeometry(1.4, 0);
                const invaderMaterial = new THREE.MeshPhysicalMaterial({ 
                    color: 0x00ff88,
                    metalness: 0.4,
                    roughness: 0.4,
                    emissive: 0x002244,
                    emissiveIntensity: 0.4,
                    transparent: true,
                    opacity: 0.85
                });
                const invader = new THREE.Mesh(invaderGeometry, invaderMaterial);
                invader.castShadow = true;
                invader.receiveShadow = true;
                invaderGroup.add(invader);
                invaderGroup.userData = { type: 'scout' };
            }
            
            // Add glow effect
            const glowGeometry = new THREE.SphereGeometry(2.5, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: invaderGroup.children[0].material.color,
                transparent: true,
                opacity: 0.1,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            invaderGroup.add(glow);
            invaderGroup.userData.glow = glow;
            
            invaderGroup.position.set(col * 6 - 12, 30 - row * 6, 0);
            scene.add(invaderGroup);
            invaders.push(invaderGroup);
        }
    }
    console.log('Created', invaders.length, 'enhanced invaders');
    
    // Reset ship position
    ship.position.set(0, -30, 0);
    
    // Reset stars positions for fresh flying effect
    stars.forEach(starGroup => {
        starGroup.position.z = Math.random() * 200 - 300;
        starGroup.position.x = Math.random() * 300 - 150;
        starGroup.position.y = Math.random() * 300 - 150;
        starGroup.scale.setScalar(0.5);
        starGroup.rotation.z = 0;
    });
    
    console.log('Game reset complete!');
}
window.resetGame = resetGame;

// Initialize audio
function initAudio() {
    try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Create shooting sound (laser zap)
        function createShootSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.1);
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
        }
        
        shootSound = createShootSound;
    } catch (e) {
        console.log('Audio not supported:', e);
    }
}

// Initialize the scene
function init() {
    // Initialize audio
    initAudio();
    
    // Create scene with realistic space background
    scene = new THREE.Scene();
    
    // Create realistic starfield background
    const canvas = document.createElement('canvas');
    canvas.width = 2048;
    canvas.height = 2048;
    const context = canvas.getContext('2d');
    
    // Deep space black background
    context.fillStyle = '#000011';
    context.fillRect(0, 0, 2048, 2048);
    
    // Add realistic stars with varying brightness and colors
    for (let i = 0; i < 3000; i++) {
        const x = Math.random() * 2048;
        const y = Math.random() * 2048;
        const brightness = Math.random();
        const size = brightness * 3 + 0.5;
        
        // Different star colors based on temperature
        let color;
        const temp = Math.random();
        if (temp < 0.3) {
            color = `rgba(255, ${200 + Math.random() * 55}, ${150 + Math.random() * 50}, ${brightness})`;
        } else if (temp < 0.6) {
            color = `rgba(255, 255, ${200 + Math.random() * 55}, ${brightness})`;
        } else if (temp < 0.9) {
            color = `rgba(${200 + Math.random() * 55}, ${220 + Math.random() * 35}, 255, ${brightness})`;
        } else {
            color = `rgba(${150 + Math.random() * 50}, ${150 + Math.random() * 50}, 255, ${brightness})`;
        }
        
        context.fillStyle = color;
        context.beginPath();
        context.arc(x, y, size, 0, Math.PI * 2);
        context.fill();
        
        // Add twinkle effect for brighter stars
        if (brightness > 0.8) {
            context.fillStyle = `rgba(255, 255, 255, ${brightness * 0.3})`;
            context.beginPath();
            context.arc(x, y, size * 2, 0, Math.PI * 2);
            context.fill();
        }
    }
    
    // Add distant nebula clouds
    for (let i = 0; i < 8; i++) {
        const x = Math.random() * 2048;
        const y = Math.random() * 2048;
        const radius = 100 + Math.random() * 200;
        const nebulaGradient = context.createRadialGradient(x, y, 0, x, y, radius);
        
        const hue = Math.random() * 360;
        nebulaGradient.addColorStop(0, `hsla(${hue}, 60%, 30%, 0.1)`);
        nebulaGradient.addColorStop(0.5, `hsla(${hue}, 70%, 20%, 0.05)`);
        nebulaGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        
        context.fillStyle = nebulaGradient;
        context.fillRect(x - radius, y - radius, radius * 2, radius * 2);
    }
    
    // Add the Milky Way band
    const milkyWayGradient = context.createLinearGradient(0, 1024, 2048, 1024);
    milkyWayGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
    milkyWayGradient.addColorStop(0.3, 'rgba(100, 80, 120, 0.1)');
    milkyWayGradient.addColorStop(0.5, 'rgba(150, 120, 180, 0.15)');
    milkyWayGradient.addColorStop(0.7, 'rgba(100, 80, 120, 0.1)');
    milkyWayGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
    
    context.fillStyle = milkyWayGradient;
    context.fillRect(0, 800, 2048, 448);
    
    const texture = new THREE.CanvasTexture(canvas);
    scene.background = texture;

    // Create perspective camera (field of view, aspect ratio, near/far clipping)
    const aspect = window.innerWidth / window.innerHeight;
    camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
    camera.position.z = 50; // Move camera back to see the scene

    // Create renderer with advanced settings
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    document.body.appendChild(renderer.domElement);

    // Enhanced lighting system for dramatic 3D effects
    const ambientLight = new THREE.AmbientLight(0x0a0a2a, 0.3); // Dark blue ambient
    scene.add(ambientLight);
    
    // Main directional light (sun-like)
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
    directionalLight.position.set(10, 20, 50);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    scene.add(directionalLight);
    
    // Dynamic colored lights
    const playerLight = new THREE.PointLight(0x00ff00, 2, 50); // Green light from player
    playerLight.position.set(0, -25, 10);
    scene.add(playerLight);
    
    const enemyLight = new THREE.PointLight(0xffff00, 1.5, 80); // Yellow light from enemies
    enemyLight.position.set(0, 20, 15);
    scene.add(enemyLight);
    
    // Pulsing blue accent light
    const accentLight = new THREE.PointLight(0x0088ff, 1, 100);
    accentLight.position.set(-30, 0, 20);
    scene.add(accentLight);
    
    // Store lights for animation
    window.gameData = { playerLight, enemyLight, accentLight };

    // Enhanced star field with nebula-like effects
    for (let i = 0; i < 50; i++) {
        const starGroup = new THREE.Group();
        
        // Create different star types
        const starType = Math.random();
        let starCore;
        
        if (starType < 0.6) {
            // Regular white stars
            starCore = new THREE.Mesh(
                new THREE.SphereGeometry(0.3 + Math.random() * 0.4), 
                new THREE.MeshBasicMaterial({ 
                    color: 0xffffff, 
                    emissive: 0xffffff,
                    emissiveIntensity: 0.8 + Math.random() * 0.4
                })
            );
        } else if (starType < 0.8) {
            // Blue giant stars
            starCore = new THREE.Mesh(
                new THREE.SphereGeometry(0.5 + Math.random() * 0.3), 
                new THREE.MeshBasicMaterial({ 
                    color: 0x4488ff, 
                    emissive: 0x2266dd,
                    emissiveIntensity: 1.0 + Math.random() * 0.5
                })
            );
        } else {
            // Red giant stars
            starCore = new THREE.Mesh(
                new THREE.SphereGeometry(0.6 + Math.random() * 0.4), 
                new THREE.MeshBasicMaterial({ 
                    color: 0xff4444, 
                    emissive: 0xdd2222,
                    emissiveIntensity: 0.9 + Math.random() * 0.3
                })
            );
        }
        starGroup.add(starCore);
        
        // Enhanced star trails with color variation
        const trailCount = 2 + Math.floor(Math.random() * 3);
        for (let j = 0; j < trailCount; j++) {
            const trailGeometry = new THREE.ConeGeometry(0.03 + j * 0.015, 1.5 + j * 1.2, 8);
            const trailColor = starCore.material.color.clone();
            const trailMaterial = new THREE.MeshBasicMaterial({ 
                color: trailColor, 
                transparent: true, 
                opacity: 0.5 - j * 0.12,
                emissive: trailColor,
                emissiveIntensity: 0.3 - j * 0.08
            });
            const trail = new THREE.Mesh(trailGeometry, trailMaterial);
            trail.rotation.x = Math.PI;
            trail.position.z = -0.8 - j * 1.2;
            starGroup.add(trail);
        }
        
        // Add subtle glow effect
        const glowGeometry = new THREE.SphereGeometry(starCore.geometry.parameters.radius * 2, 16, 16);
        const glowMaterial = new THREE.MeshBasicMaterial({
            color: starCore.material.color,
            transparent: true,
            opacity: 0.1,
            side: THREE.BackSide
        });
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        starGroup.add(glow);
        
        // Position star randomly in 3D space
        starGroup.position.set(
            Math.random() * 300 - 150, 
            Math.random() * 300 - 150, 
            Math.random() * 200 - 300
        );
        
        scene.add(starGroup);
        stars.push(starGroup);
    }

    // Advanced spaceship with detailed geometry and effects
    const shipGroup = new THREE.Group();
    
    // Main fuselage (sleeker design)
    const fuselageGeometry = new THREE.CylinderGeometry(0.8, 1.2, 7, 16);
    const fuselageMaterial = new THREE.MeshPhysicalMaterial({ 
        color: 0x00cc00,
        metalness: 0.9,
        roughness: 0.1,
        clearcoat: 1.0,
        clearcoatRoughness: 0.05,
        emissive: 0x003300,
        emissiveIntensity: 0.4
    });
    const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial);
    fuselage.rotation.x = Math.PI;
    fuselage.castShadow = true;
    fuselage.receiveShadow = true;
    shipGroup.add(fuselage);
    
    // Nose cone
    const noseGeometry = new THREE.ConeGeometry(0.8, 2, 16);
    const noseMaterial = new THREE.MeshPhysicalMaterial({
        color: 0x00ff00,
        metalness: 0.95,
        roughness: 0.05,
        clearcoat: 1.0,
        emissive: 0x004400,
        emissiveIntensity: 0.6
    });
    const nose = new THREE.Mesh(noseGeometry, noseMaterial);
    nose.position.set(0, 4.5, 0);
    nose.castShadow = true;
    nose.receiveShadow = true;
    shipGroup.add(nose);
    
    // Main wings (swept back design)
    const wingGeometry = new THREE.BoxGeometry(6, 0.4, 3);
    const wingMaterial = new THREE.MeshPhysicalMaterial({ 
        color: 0x008800,
        metalness: 0.8,
        roughness: 0.2,
        clearcoat: 0.9,
        emissive: 0x002200,
        emissiveIntensity: 0.3
    });
    const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
    leftWing.position.set(-3, -0.5, -0.5);
    leftWing.rotation.z = -0.2;
    leftWing.castShadow = true;
    leftWing.receiveShadow = true;
    shipGroup.add(leftWing);
    
    const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
    rightWing.position.set(3, -0.5, -0.5);
    rightWing.rotation.z = 0.2;
    rightWing.castShadow = true;
    rightWing.receiveShadow = true;
    shipGroup.add(rightWing);
    
    // Wing tip lights
    const wingTipGeometry = new THREE.SphereGeometry(0.2, 8, 8);
    const leftTipMaterial = new THREE.MeshBasicMaterial({
        color: 0xff0000,
        emissive: 0xff0000,
        emissiveIntensity: 1.0
    });
    const rightTipMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ff00,
        emissive: 0x00ff00,
        emissiveIntensity: 1.0
    });
    const leftTip = new THREE.Mesh(wingTipGeometry, leftTipMaterial);
    leftTip.position.set(-6, -0.5, -0.5);
    shipGroup.add(leftTip);
    
    const rightTip = new THREE.Mesh(wingTipGeometry, rightTipMaterial);
    rightTip.position.set(6, -0.5, -0.5);
    shipGroup.add(rightTip);
    
    // Cockpit with enhanced glass effect
    const cockpitGeometry = new THREE.SphereGeometry(1.0, 20, 20);
    const cockpitMaterial = new THREE.MeshPhysicalMaterial({ 
        color: 0x88ffff,
        metalness: 0.0,
        roughness: 0.0,
        transmission: 0.9,
        transparent: true,
        opacity: 0.2,
        clearcoat: 1.0,
        clearcoatRoughness: 0.0,
        emissive: 0x006666,
        emissiveIntensity: 0.7,
        ior: 1.5
    });
    const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
    cockpit.position.set(0, 1.5, 0);
    cockpit.scale.set(1, 0.6, 1);
    cockpit.castShadow = true;
    cockpit.receiveShadow = true;
    shipGroup.add(cockpit);
    
    // Dual engine exhausts
    const engineGeometry = new THREE.CylinderGeometry(0.4, 0.6, 2, 12);
    const engineMaterial = new THREE.MeshPhysicalMaterial({ 
        color: 0x333333,
        metalness: 1.0,
        roughness: 0.3,
        emissive: 0x001144,
        emissiveIntensity: 0.8
    });
    
    const leftEngine = new THREE.Mesh(engineGeometry, engineMaterial);
    leftEngine.position.set(-1.5, -3.5, 0);
    leftEngine.castShadow = true;
    leftEngine.receiveShadow = true;
    shipGroup.add(leftEngine);
    
    const rightEngine = new THREE.Mesh(engineGeometry, engineMaterial);
    rightEngine.position.set(1.5, -3.5, 0);
    rightEngine.castShadow = true;
    rightEngine.receiveShadow = true;
    shipGroup.add(rightEngine);
    
    // Engine glow effects
    const engineGlowGeometry = new THREE.SphereGeometry(0.5, 12, 12);
    const leftGlowMaterial = new THREE.MeshBasicMaterial({
        color: 0x00aaff,
        transparent: true,
        opacity: 0.8,
        emissive: 0x0088ff,
        emissiveIntensity: 1.5
    });
    const rightGlowMaterial = new THREE.MeshBasicMaterial({
        color: 0x00aaff,
        transparent: true,
        opacity: 0.8,
        emissive: 0x0088ff,
        emissiveIntensity: 1.5
    });
    
    const leftGlow = new THREE.Mesh(engineGlowGeometry, leftGlowMaterial);
    leftGlow.position.set(-1.5, -4.5, 0);
    shipGroup.add(leftGlow);
    
    const rightGlow = new THREE.Mesh(engineGlowGeometry, rightGlowMaterial);
    rightGlow.position.set(1.5, -4.5, 0);
    shipGroup.add(rightGlow);
    
    // Add engine particle trails
    const trailGeometry = new THREE.ConeGeometry(0.3, 1.5, 8);
    const trailMaterial = new THREE.MeshBasicMaterial({
        color: 0x0066ff,
        transparent: true,
        opacity: 0.6,
        emissive: 0x0066ff,
        emissiveIntensity: 1.0
    });
    
    const leftTrail = new THREE.Mesh(trailGeometry, trailMaterial);
    leftTrail.position.set(-1.5, -5.5, 0);
    leftTrail.rotation.x = Math.PI;
    shipGroup.add(leftTrail);
    
    const rightTrail = new THREE.Mesh(trailGeometry, trailMaterial);
    rightTrail.position.set(1.5, -5.5, 0);
    rightTrail.rotation.x = Math.PI;
    shipGroup.add(rightTrail);
    
    // Add weapon hardpoints
    const weaponGeometry = new THREE.BoxGeometry(0.3, 0.3, 1.5);
    const weaponMaterial = new THREE.MeshPhysicalMaterial({
        color: 0x444444,
        metalness: 0.9,
        roughness: 0.1,
        emissive: 0x220000,
        emissiveIntensity: 0.5
    });
    
    const leftWeapon = new THREE.Mesh(weaponGeometry, weaponMaterial);
    leftWeapon.position.set(-2.5, 1, 0);
    leftWeapon.castShadow = true;
    shipGroup.add(leftWeapon);
    
    const rightWeapon = new THREE.Mesh(weaponGeometry, weaponMaterial);
    rightWeapon.position.set(2.5, 1, 0);
    rightWeapon.castShadow = true;
    shipGroup.add(rightWeapon);
    
    // Store components for animation
    shipGroup.userData = { 
        leftGlow, 
        rightGlow, 
        leftTrail, 
        rightTrail,
        leftTip,
        rightTip,
        cockpit
    };
    
    ship = shipGroup;
    ship.position.y = -30; // Bottom of screen
    scene.add(ship);

    // Create enhanced invaders with varied designs
    for (let row = 0; row < 3; row++) {
        for (let col = 0; col < 5; col++) {
            const invaderGroup = new THREE.Group();
            
            // Different invader types per row
            if (row === 0) {
                // Top row - Elite invaders (octahedron shape)
                const invaderGeometry = new THREE.OctahedronGeometry(1.8, 1);
                const invaderMaterial = new THREE.MeshPhysicalMaterial({ 
                    color: 0xff6600,
                    metalness: 0.9,
                    roughness: 0.1,
                    emissive: 0x331100,
                    emissiveIntensity: 0.8,
                    transparent: true,
                    opacity: 0.95
                });
                const invader = new THREE.Mesh(invaderGeometry, invaderMaterial);
                invader.castShadow = true;
                invader.receiveShadow = true;
                invaderGroup.add(invader);
                
                // Add spinning rings
                const ringGeometry = new THREE.RingGeometry(2, 2.5, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff3300,
                    transparent: true,
                    opacity: 0.6,
                    emissive: 0xff3300,
                    emissiveIntensity: 0.4,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI / 2;
                invaderGroup.add(ring);
                invaderGroup.userData = { ring, type: 'elite' };
                
            } else if (row === 1) {
                // Middle row - Standard invaders (icosahedron)
                const invaderGeometry = new THREE.IcosahedronGeometry(1.6, 0);
                const invaderMaterial = new THREE.MeshPhysicalMaterial({ 
                    color: 0xffff00,
                    metalness: 0.6,
                    roughness: 0.3,
                    emissive: 0x444400,
                    emissiveIntensity: 0.6,
                    transparent: true,
                    opacity: 0.9
                });
                const invader = new THREE.Mesh(invaderGeometry, invaderMaterial);
                invader.castShadow = true;
                invader.receiveShadow = true;
                invaderGroup.add(invader);
                invaderGroup.userData = { type: 'standard' };
                
            } else {
                // Bottom row - Scout invaders (tetrahedron)
                const invaderGeometry = new THREE.TetrahedronGeometry(1.4, 0);
                const invaderMaterial = new THREE.MeshPhysicalMaterial({ 
                    color: 0x00ff88,
                    metalness: 0.4,
                    roughness: 0.4,
                    emissive: 0x002244,
                    emissiveIntensity: 0.4,
                    transparent: true,
                    opacity: 0.85
                });
                const invader = new THREE.Mesh(invaderGeometry, invaderMaterial);
                invader.castShadow = true;
                invader.receiveShadow = true;
                invaderGroup.add(invader);
                invaderGroup.userData = { type: 'scout' };
            }
            
            // Add pulsing glow effect
            const glowGeometry = new THREE.SphereGeometry(2.5, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: invaderGroup.children[0].material.color,
                transparent: true,
                opacity: 0.1,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            invaderGroup.add(glow);
            invaderGroup.userData.glow = glow;
            
            invaderGroup.position.set(col * 6 - 12, 30 - row * 6, 0);
            scene.add(invaderGroup);
            invaders.push(invaderGroup);
        }
    }

    // Keyboard controls
document.addEventListener('keydown', (event) => { keys[event.key] = true; });
document.addEventListener('keyup', (event) => { keys[event.key] = false; });

// Mobile detection
function isMobile() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
           window.innerWidth <= 768;
}
window.isMobile = isMobile;

// Finger control functions
function initFingerControls() {
    const touchArea = document.getElementById('touchArea');
    console.log('Initializing finger controls, touchArea:', touchArea);
    
    // Touch start
    touchArea.addEventListener('touchstart', (e) => {
        console.log('Touch start detected!');
        e.preventDefault();
        const touch = e.touches[0];
        isTouching = true;
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
        lastTouchX = touch.clientX;
        lastTouchY = touch.clientY;
        
        // Start auto-fire
        startAutoFire();
    });
    
    // Touch move
    touchArea.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (!isTouching) return;
        
        const touch = e.touches[0];
        const deltaX = touch.clientX - lastTouchX;
        const deltaY = touch.clientY - lastTouchY;
        
        console.log('Touch move - deltaX:', deltaX, 'ship position:', ship.position.x);
        
        // Move ship based on touch movement - increased sensitivity
        if (Math.abs(deltaX) > touchMoveThreshold / 50) { // Lower threshold for more sensitivity
            const moveSpeed = deltaX * 0.1; // Increased from 0.02 to 0.1 for more sensitivity
            ship.position.x += moveSpeed;
            
            // Keep ship within bounds
            ship.position.x = Math.max(-40, Math.min(40, ship.position.x));
        }
        
        lastTouchX = touch.clientX;
        lastTouchY = touch.clientY;
    });
    
    // Touch end
    touchArea.addEventListener('touchend', (e) => {
        console.log('Touch end detected!');
        e.preventDefault();
        isTouching = false;
        
        // Stop auto-fire
        stopAutoFire();
    });
    
    // Mouse support for desktop testing
    touchArea.addEventListener('mousedown', (e) => {
        e.preventDefault();
        isTouching = true;
        touchStartX = e.clientX;
        touchStartY = e.clientY;
        lastTouchX = e.clientX;
        lastTouchY = e.clientY;
        
        startAutoFire();
    });
    
    touchArea.addEventListener('mousemove', (e) => {
        e.preventDefault();
        if (!isTouching) return;
        
        const deltaX = e.clientX - lastTouchX;
        const deltaY = e.clientY - lastTouchY;
        
        if (Math.abs(deltaX) > touchMoveThreshold / 50) { // Lower threshold for more sensitivity
            const moveSpeed = deltaX * 0.1; // Increased sensitivity
            ship.position.x += moveSpeed;
            ship.position.x = Math.max(-40, Math.min(40, ship.position.x));
        }
        
        lastTouchX = e.clientX;
        lastTouchY = e.clientY;
    });
    
    touchArea.addEventListener('mouseup', (e) => {
        e.preventDefault();
        isTouching = false;
        stopAutoFire();
    });
    
    touchArea.addEventListener('mouseleave', (e) => {
        e.preventDefault();
        isTouching = false;
        stopAutoFire();
    });
}

// Auto-fire functions
function startAutoFire() {
    if (autoFireInterval) return;
    autoFireInterval = setInterval(() => {
        if (!gameOver && isTouching) {
            // Create realistic missile projectile
            const missileGroup = new THREE.Group();
            
            // Main missile body (cylindrical with pointed nose)
            const bodyGeometry = new THREE.CylinderGeometry(0.2, 0.25, 2.5, 12);
            const bodyMaterial = new THREE.MeshPhysicalMaterial({ 
                color: 0x444444,
                metalness: 0.8,
                roughness: 0.3,
                emissive: 0x220000,
                emissiveIntensity: 0.3
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.rotation.x = Math.PI / 2;
            body.castShadow = true;
            missileGroup.add(body);
            
            // Missile nose cone
            const noseGeometry = new THREE.ConeGeometry(0.2, 0.8, 12);
            const noseMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x666666,
                metalness: 0.9,
                roughness: 0.1,
                emissive: 0x330000,
                emissiveIntensity: 0.4
            });
            const nose = new THREE.Mesh(noseGeometry, noseMaterial);
            nose.position.set(0, 1.65, 0);
            nose.castShadow = true;
            missileGroup.add(nose);
            
            // Missile fins
            const finGeometry = new THREE.BoxGeometry(0.6, 0.05, 0.4);
            const finMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x333333,
                metalness: 0.7,
                roughness: 0.4,
                emissive: 0x110000,
                emissiveIntensity: 0.2
            });
            
            // Create 4 fins
            for (let i = 0; i < 4; i++) {
                const fin = new THREE.Mesh(finGeometry, finMaterial);
                const angle = (i / 4) * Math.PI * 2;
                fin.position.set(
                    Math.cos(angle) * 0.3,
                    -1,
                    Math.sin(angle) * 0.3
                );
                fin.rotation.y = angle;
                fin.castShadow = true;
                missileGroup.add(fin);
            }
            
            // Engine exhaust glow
            const exhaustGeometry = new THREE.CylinderGeometry(0.15, 0.1, 0.3, 8);
            const exhaustMaterial = new THREE.MeshBasicMaterial({
                color: 0xff4400,
                transparent: true,
                opacity: 0.8,
                emissive: 0xff4400,
                emissiveIntensity: 2.0
            });
            const exhaust = new THREE.Mesh(exhaustGeometry, exhaustMaterial);
            exhaust.position.set(0, -1.4, 0);
            exhaust.rotation.x = Math.PI / 2;
            missileGroup.add(exhaust);
            
            // Smoke trail particles
            const trailParticles = [];
            for (let i = 0; i < 8; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.08 + i * 0.02, 6, 6);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(0.1, 0.3, 0.6 - i * 0.06),
                    transparent: true,
                    opacity: 0.7 - i * 0.08,
                    emissive: 0x442200,
                    emissiveIntensity: 0.5 - i * 0.05
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.set(
                    (Math.random() - 0.5) * 0.3,
                    -1.5 - i * 0.3,
                    (Math.random() - 0.5) * 0.3
                );
                trailParticles.push(particle);
                missileGroup.add(particle);
            }
            
            // Add targeting light
            const targetLightGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const targetLightMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                emissive: 0x00ff00,
                emissiveIntensity: 1.5
            });
            const targetLight = new THREE.Mesh(targetLightGeometry, targetLightMaterial);
            targetLight.position.set(0, 0.5, 0);
            missileGroup.add(targetLight);
            
            missileGroup.position.set(ship.position.x, ship.position.y + 3, 0);
            missileGroup.userData = { 
                type: 'player', 
                trailParticles,
                exhaust,
                targetLight,
                speed: 2.0,
                spinSpeed: 0.05
            };
            scene.add(missileGroup);
            projectiles.push(missileGroup);
            
            // Play shooting sound
            if (shootSound) {
                shootSound();
            }
        }
    }, autoFireRate);
}

function stopAutoFire() {
    if (autoFireInterval) {
        clearInterval(autoFireInterval);
        autoFireInterval = null;
    }
}
window.stopAutoFire = stopAutoFire;

// Mobile touch controls
function initMobileControls() {
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');
    const fireBtn = document.getElementById('fireBtn');
    
    // Left button
    leftBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        keys['ArrowLeft'] = true;
        leftBtn.classList.add('active');
    });
    
    leftBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        keys['ArrowLeft'] = false;
        leftBtn.classList.remove('active');
    });
    
    // Right button
    rightBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        keys['ArrowRight'] = true;
        rightBtn.classList.add('active');
    });
    
    rightBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        keys['ArrowRight'] = false;
        rightBtn.classList.remove('active');
    });
    
    // Fire button
    fireBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        keys[' '] = true;
        fireBtn.classList.add('active');
    });
    
    fireBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        keys[' '] = false;
        fireBtn.classList.remove('active');
    });
    
    // Mouse support for desktop testing
    leftBtn.addEventListener('mousedown', (e) => {
        e.preventDefault();
        keys['ArrowLeft'] = true;
        leftBtn.classList.add('active');
    });
    
    leftBtn.addEventListener('mouseup', (e) => {
        e.preventDefault();
        keys['ArrowLeft'] = false;
        leftBtn.classList.remove('active');
    });
    
    leftBtn.addEventListener('mouseleave', (e) => {
        e.preventDefault();
        keys['ArrowLeft'] = false;
        leftBtn.classList.remove('active');
    });
    
    rightBtn.addEventListener('mousedown', (e) => {
        e.preventDefault();
        keys['ArrowRight'] = true;
        rightBtn.classList.add('active');
    });
    
    rightBtn.addEventListener('mouseup', (e) => {
        e.preventDefault();
        keys['ArrowRight'] = false;
        rightBtn.classList.remove('active');
    });
    
    rightBtn.addEventListener('mouseleave', (e) => {
        e.preventDefault();
        keys['ArrowRight'] = false;
        rightBtn.classList.remove('active');
    });
    
    fireBtn.addEventListener('mousedown', (e) => {
        e.preventDefault();
        keys[' '] = true;
        fireBtn.classList.add('active');
    });
    
    fireBtn.addEventListener('mouseup', (e) => {
        e.preventDefault();
        keys[' '] = false;
        fireBtn.classList.remove('active');
    });
    
    fireBtn.addEventListener('mouseleave', (e) => {
        e.preventDefault();
        keys[' '] = false;
        fireBtn.classList.remove('active');
    });
}

    // Initialize mobile controls
    initMobileControls();
    initFingerControls();
    
    // Add click event listener for debugging
    document.addEventListener('click', (e) => {
        console.log('Click detected on:', e.target);
        if (e.target.textContent === 'Start New Game') {
            console.log('Start New Game button clicked!');
            resetGame();
        }
    });
    
    // Show/hide mobile controls based on device
    const mobileControls = document.querySelector('.mobile-controls');
    const touchArea = document.querySelector('.touch-area');
    const touchInstructions = document.querySelector('.touch-instructions');
    
    console.log('Device detection - isMobile():', isMobile());
    console.log('Touch area element:', touchArea);
    
    if (isMobile()) {
        mobileControls.style.display = 'none'; // Hide buttons, use finger controls
        touchArea.style.display = 'block';
        touchInstructions.style.display = 'block';
        controlsElement.style.display = 'none'; // Hide desktop controls
        console.log('Mobile mode activated - touch area should be visible');
    } else {
        mobileControls.style.display = 'none';
        touchArea.style.display = 'none';
        touchInstructions.style.display = 'none';
        controlsElement.style.display = 'block'; // Show desktop controls
        console.log('Desktop mode activated');
    }
    
    // Make it responsive
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        
        // Update mobile controls visibility on resize
        const touchInstructions = document.querySelector('.touch-instructions');
        if (isMobile()) {
            mobileControls.style.display = 'none'; // Hide buttons, use finger controls
            touchArea.style.display = 'block';
            touchInstructions.style.display = 'block';
            controlsElement.style.display = 'none';
        } else {
            mobileControls.style.display = 'none';
            touchArea.style.display = 'none';
            touchInstructions.style.display = 'none';
            controlsElement.style.display = 'block';
        }
    });

    // Call the animation loop
    animate();
}

// Animation loop (runs every frame)
function animate() {
    requestAnimationFrame(animate); // Loop this function
    
    // Update player position (only if game is not over)
    if (!gameOver) {
        if (keys['ArrowLeft'] && ship.position.x > -40) ship.position.x -= 0.5;
        if (keys['ArrowRight'] && ship.position.x < 40) ship.position.x += 0.5;

                // Shoot on spacebar (limit firing rate)
        if (keys[' ']) {
            // Create realistic missile projectile
            const missileGroup = new THREE.Group();
            
            // Main missile body (cylindrical with pointed nose)
            const bodyGeometry = new THREE.CylinderGeometry(0.2, 0.25, 2.5, 12);
            const bodyMaterial = new THREE.MeshPhysicalMaterial({ 
                color: 0x444444,
                metalness: 0.8,
                roughness: 0.3,
                emissive: 0x220000,
                emissiveIntensity: 0.3
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.rotation.x = Math.PI / 2;
            body.castShadow = true;
            missileGroup.add(body);
            
            // Missile nose cone
            const noseGeometry = new THREE.ConeGeometry(0.2, 0.8, 12);
            const noseMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x666666,
                metalness: 0.9,
                roughness: 0.1,
                emissive: 0x330000,
                emissiveIntensity: 0.4
            });
            const nose = new THREE.Mesh(noseGeometry, noseMaterial);
            nose.position.set(0, 1.65, 0);
            nose.castShadow = true;
            missileGroup.add(nose);
            
            // Missile fins
            const finGeometry = new THREE.BoxGeometry(0.6, 0.05, 0.4);
            const finMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x333333,
                metalness: 0.7,
                roughness: 0.4,
                emissive: 0x110000,
                emissiveIntensity: 0.2
            });
            
            // Create 4 fins
            for (let i = 0; i < 4; i++) {
                const fin = new THREE.Mesh(finGeometry, finMaterial);
                const angle = (i / 4) * Math.PI * 2;
                fin.position.set(
                    Math.cos(angle) * 0.3,
                    -1,
                    Math.sin(angle) * 0.3
                );
                fin.rotation.y = angle;
                fin.castShadow = true;
                missileGroup.add(fin);
            }
            
            // Engine exhaust glow
            const exhaustGeometry = new THREE.CylinderGeometry(0.15, 0.1, 0.3, 8);
            const exhaustMaterial = new THREE.MeshBasicMaterial({
                color: 0xff4400,
                transparent: true,
                opacity: 0.8,
                emissive: 0xff4400,
                emissiveIntensity: 2.0
            });
            const exhaust = new THREE.Mesh(exhaustGeometry, exhaustMaterial);
            exhaust.position.set(0, -1.4, 0);
            exhaust.rotation.x = Math.PI / 2;
            missileGroup.add(exhaust);
            
            // Smoke trail particles
            const trailParticles = [];
            for (let i = 0; i < 8; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.08 + i * 0.02, 6, 6);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(0.1, 0.3, 0.6 - i * 0.06),
                    transparent: true,
                    opacity: 0.7 - i * 0.08,
                    emissive: 0x442200,
                    emissiveIntensity: 0.5 - i * 0.05
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.set(
                    (Math.random() - 0.5) * 0.3,
                    -1.5 - i * 0.3,
                    (Math.random() - 0.5) * 0.3
                );
                trailParticles.push(particle);
                missileGroup.add(particle);
            }
            
            // Add targeting light
            const targetLightGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const targetLightMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                emissive: 0x00ff00,
                emissiveIntensity: 1.5
            });
            const targetLight = new THREE.Mesh(targetLightGeometry, targetLightMaterial);
            targetLight.position.set(0, 0.5, 0);
            missileGroup.add(targetLight);
            
            missileGroup.position.set(ship.position.x, ship.position.y + 3, 0);
            missileGroup.userData = { 
                type: 'player', 
                trailParticles,
                exhaust,
                targetLight,
                speed: 2.0,
                spinSpeed: 0.05
            };
            scene.add(missileGroup);
            projectiles.push(missileGroup);
            
            // Play shooting sound
            if (shootSound) {
                shootSound();
            }
            
            keys[' '] = false; // Prevent rapid fire (add timer for better control later)
        }
    }

    // Move projectiles with realistic physics and animations
    projectiles.forEach((proj, index) => {
        const dir = proj.direction || 1; // Player: 1 up, enemy: -1 down
        const time = Date.now() * 0.001;
        
        if (proj.mesh) { // Enemy bomb projectile
            const speed = proj.userData && proj.userData.speed ? proj.userData.speed : 1.5;
            proj.mesh.position.y += speed * dir;
            
            // Animate enemy bomb effects
            if (proj.mesh.userData) {
                const userData = proj.mesh.userData;
                
                // Spin the bomb
                proj.mesh.rotation.x += userData.spinSpeed || 0.02;
                proj.mesh.rotation.z += userData.spinSpeed * 0.7 || 0.014;
                
                // Animate energy core pulsing
                if (userData.core) {
                    const pulse = 1 + Math.sin(time * 8) * 0.3;
                    userData.core.scale.setScalar(pulse);
                    userData.core.material.emissiveIntensity = 1.5 + Math.sin(time * 6) * 0.5;
                }
                
                // Animate energy field
                if (userData.field) {
                    const fieldPulse = 1 + Math.sin(time * 4) * 0.2;
                    userData.field.scale.setScalar(fieldPulse);
                    userData.field.material.opacity = 0.2 + Math.sin(time * 5) * 0.1;
                }
                
                // Animate orbiting sparks
                if (userData.sparkParticles) {
                    userData.sparkParticles.forEach((spark, sparkIndex) => {
                        const angle = time * userData.sparkOrbitSpeed + (sparkIndex / userData.sparkParticles.length) * Math.PI * 2;
                        const radius = userData.bombSize * 2;
                        spark.position.x = Math.cos(angle) * radius;
                        spark.position.y = Math.sin(angle) * radius;
                        spark.material.emissiveIntensity = 1.2 + Math.sin(time * 10 + sparkIndex) * 0.3;
                    });
                }
            }
            
            // Remove off-screen projectiles
            if (proj.mesh.position.y < -50) {
                scene.remove(proj.mesh);
                projectiles.splice(index, 1);
            }
        } else { // Player missile projectile
            const speed = proj.userData && proj.userData.speed ? proj.userData.speed : 2.0;
            proj.position.y += speed * dir;
            
            // Animate player missile effects
            if (proj.userData && proj.userData.type === 'player') {
                const userData = proj.userData;
                
                // Spin the missile
                proj.rotation.z += userData.spinSpeed || 0.05;
                
                // Animate engine exhaust
                if (userData.exhaust) {
                    const exhaustPulse = 1 + Math.sin(time * 15) * 0.4;
                    userData.exhaust.scale.setScalar(exhaustPulse);
                    userData.exhaust.material.emissiveIntensity = 2.0 + Math.sin(time * 12) * 0.8;
                }
                
                // Animate targeting light
                if (userData.targetLight) {
                    userData.targetLight.material.emissiveIntensity = 1.5 + Math.sin(time * 8) * 0.5;
                }
                
                // Animate smoke trail particles
                if (userData.trailParticles) {
                    userData.trailParticles.forEach((particle, particleIndex) => {
                        // Create turbulence effect
                        particle.position.x += (Math.random() - 0.5) * 0.02;
                        particle.position.z += (Math.random() - 0.5) * 0.02;
                        
                        // Fade trail particles over time
                        const fadeRate = 0.002;
                        particle.material.opacity = Math.max(0, particle.material.opacity - fadeRate);
                        particle.material.emissiveIntensity = Math.max(0, particle.material.emissiveIntensity - fadeRate);
                        
                        // Expand trail particles
                        const expansion = 1 + particleIndex * 0.001;
                        particle.scale.setScalar(expansion);
                    });
                }
                
                // Add slight homing effect (subtle course correction)
                if (invaders.length > 0) {
                    const nearestInvader = invaders.reduce((nearest, invader) => {
                        const distToNearest = nearest ? 
                            Math.abs(proj.position.x - nearest.position.x) + Math.abs(proj.position.y - nearest.position.y) :
                            Infinity;
                        const distToCurrent = Math.abs(proj.position.x - invader.position.x) + Math.abs(proj.position.y - invader.position.y);
                        return distToCurrent < distToNearest ? invader : nearest;
                    }, null);
                    
                    if (nearestInvader) {
                        const dx = nearestInvader.position.x - proj.position.x;
                        const homingStrength = 0.02;
                        proj.position.x += dx * homingStrength;
                    }
                }
            }
            
            // Remove off-screen projectiles
            if (proj.position.y > 50) {
                scene.remove(proj);
                projectiles.splice(index, 1);
            }
        }
    });

        // Check collisions
    projectiles.forEach((proj, pIndex) => {
        if (!proj.direction) { // Player projectile hitting invaders
            for (let iIndex = invaders.length - 1; iIndex >= 0; iIndex--) {
                const inv = invaders[iIndex];
                // Simple bounding box collision (check distance) - adjusted for smaller invaders
                if (Math.abs(proj.position.x - inv.position.x) < 2 &&
                    Math.abs(proj.position.y - inv.position.y) < 2) {
                    
                    // Create explosion at invader position
                    createExplosion(inv.position.x, inv.position.y, inv.position.z, 'bomb_impact');
                    
                    scene.remove(proj);
                    scene.remove(inv);
                    projectiles.splice(pIndex, 1);
                    invaders.splice(iIndex, 1);
                    
                    // Different points for different invader types
                    let points = 10;
                    if (inv.userData.type === 'elite') points = 30;
                    else if (inv.userData.type === 'standard') points = 20;
                    else if (inv.userData.type === 'scout') points = 10;
                    
                    score += points;
                    scoreElement.innerText = `Score: ${score}`;
                    
                    // Check if all invaders are gone
                    if (invaders.length === 0) {
                        wave++;
                        console.log('All invaders destroyed! Creating wave', wave);
                        
                        // Create new enhanced wave
                        for (let row = 0; row < 3; row++) {
                            for (let col = 0; col < 5; col++) {
                                const invaderGroup = new THREE.Group();
                                
                                // Different invader types per row (same as initial creation)
                                if (row === 0) {
                                    // Elite invaders
                                    const invaderGeometry = new THREE.OctahedronGeometry(1.8, 1);
                                    const invaderMaterial = new THREE.MeshPhysicalMaterial({ 
                                        color: 0xff6600,
                                        metalness: 0.9,
                                        roughness: 0.1,
                                        emissive: 0x331100,
                                        emissiveIntensity: 0.8,
                                        transparent: true,
                                        opacity: 0.95
                                    });
                                    const invader = new THREE.Mesh(invaderGeometry, invaderMaterial);
                                    invader.castShadow = true;
                                    invader.receiveShadow = true;
                                    invaderGroup.add(invader);
                                    
                                    const ringGeometry = new THREE.RingGeometry(2, 2.5, 16);
                                    const ringMaterial = new THREE.MeshBasicMaterial({
                                        color: 0xff3300,
                                        transparent: true,
                                        opacity: 0.6,
                                        emissive: 0xff3300,
                                        emissiveIntensity: 0.4,
                                        side: THREE.DoubleSide
                                    });
                                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                                    ring.rotation.x = Math.PI / 2;
                                    invaderGroup.add(ring);
                                    invaderGroup.userData = { ring, type: 'elite' };
                                    
                                } else if (row === 1) {
                                    // Standard invaders
                                    const invaderGeometry = new THREE.IcosahedronGeometry(1.6, 0);
                                    const invaderMaterial = new THREE.MeshPhysicalMaterial({ 
                                        color: 0xffff00,
                                        metalness: 0.6,
                                        roughness: 0.3,
                                        emissive: 0x444400,
                                        emissiveIntensity: 0.6,
                                        transparent: true,
                                        opacity: 0.9
                                    });
                                    const invader = new THREE.Mesh(invaderGeometry, invaderMaterial);
                                    invader.castShadow = true;
                                    invader.receiveShadow = true;
                                    invaderGroup.add(invader);
                                    invaderGroup.userData = { type: 'standard' };
                                    
                                } else {
                                    // Scout invaders
                                    const invaderGeometry = new THREE.TetrahedronGeometry(1.4, 0);
                                    const invaderMaterial = new THREE.MeshPhysicalMaterial({ 
                                        color: 0x00ff88,
                                        metalness: 0.4,
                                        roughness: 0.4,
                                        emissive: 0x002244,
                                        emissiveIntensity: 0.4,
                                        transparent: true,
                                        opacity: 0.85
                                    });
                                    const invader = new THREE.Mesh(invaderGeometry, invaderMaterial);
                                    invader.castShadow = true;
                                    invader.receiveShadow = true;
                                    invaderGroup.add(invader);
                                    invaderGroup.userData = { type: 'scout' };
                                }
                                
                                // Add glow effect
                                const glowGeometry = new THREE.SphereGeometry(2.5, 16, 16);
                                const glowMaterial = new THREE.MeshBasicMaterial({
                                    color: invaderGroup.children[0].material.color,
                                    transparent: true,
                                    opacity: 0.1,
                                    side: THREE.BackSide
                                });
                                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                                invaderGroup.add(glow);
                                invaderGroup.userData.glow = glow;
                                
                                invaderGroup.position.set(col * 6 - 12, 30 - row * 6, 0);
                                scene.add(invaderGroup);
                                invaders.push(invaderGroup);
                            }
                        }
                        console.log('Created', invaders.length, 'new invaders for wave', wave);
                    }
                    break; // Exit the loop after hitting one invader
                }
            }
            
            // Check collision with SpaceX rockets
            for (let rIndex = spaceXRockets.length - 1; rIndex >= 0; rIndex--) {
                const rocket = spaceXRockets[rIndex];
                if (rocket.userData.destroyed) continue;
                
                // Check collision with rocket (larger hitbox due to rocket size)
                if (Math.abs(proj.position.x - rocket.position.x) < 4 &&
                    Math.abs(proj.position.y - rocket.position.y) < 8) {
                    
                    // Hit the rocket!
                    rocket.userData.hitCount++;
                    console.log(`SpaceX rocket hit! (${rocket.userData.hitCount}/${rocket.userData.maxHits})`);
                    
                    // Create small hit explosion
                    createExplosion(proj.position.x, proj.position.y, proj.position.z, 'rocket_hit');
                    
                    // Remove projectile
                    scene.remove(proj);
                    projectiles.splice(pIndex, 1);
                    
                    // Check if rocket is destroyed
                    if (rocket.userData.hitCount >= rocket.userData.maxHits) {
                        // Rocket destroyed! Give bonus points
                        score += 100;
                        scoreElement.innerText = `Score: ${score}`;
                        
                        // Create big explosion
                        createExplosion(rocket.position.x, rocket.position.y, rocket.position.z, 'rocket_destroyed');
                        
                        // Mark as destroyed and remove after a delay
                        rocket.userData.destroyed = true;
                        setTimeout(() => {
                            scene.remove(rocket);
                            const index = spaceXRockets.indexOf(rocket);
                            if (index > -1) {
                                spaceXRockets.splice(index, 1);
                            }
                        }, 1000);
                        
                        console.log('SpaceX rocket destroyed! +100 points');
                    } else {
                        // Just hit, add some damage effect
                        rocket.children[0].material.emissiveIntensity = 1.0; // Flash the body
                        setTimeout(() => {
                            if (rocket.children[0].material) {
                                rocket.children[0].material.emissiveIntensity = 0.3;
                            }
                        }, 200);
                    }
                    
                    break; // Exit the loop after hitting rocket
                }
            }
        } else { // Enemy projectile hitting player
                            if (proj.mesh && !gameOver) {
                const shipPos = ship.position;
                if (Math.abs(proj.mesh.position.x - shipPos.x) < 2.5 &&
                    Math.abs(proj.mesh.position.y - shipPos.y) < 2.5) {
                    // Player hit by bomb!
                    createExplosion(ship.position.x, ship.position.y, ship.position.z, 'bomb_ship');
                    scene.remove(proj.mesh);
                    projectiles.splice(pIndex, 1);
                    gameOver = true;
                    
                    // Check for new high score
                    if (score > highScore) {
                        highScore = score;
                        localStorage.setItem('spaceInvadersHighScore', highScore);
                        highScoreElement.textContent = `High Score: ${highScore}`;
                        gameOverElement.innerHTML = `
                            <div>Game Over!</div>
                            <div style="font-size: 24px; margin: 10px 0;">Score: ${score}</div>
                            <div style="font-size: 20px; color: gold; margin: 10px 0;">NEW HIGH SCORE! üéâ</div>
                            <button onclick="resetGame()" style="
                                background: #4CAF50; 
                                color: white; 
                                border: none; 
                                padding: 15px 30px; 
                                font-size: 18px; 
                                border-radius: 5px; 
                                cursor: pointer;
                                margin-top: 20px;
                            ">Start New Game</button>
                        `;
                    } else {
                        gameOverElement.innerHTML = `
                            <div>Game Over!</div>
                            <div style="font-size: 24px; margin: 10px 0;">Score: ${score}</div>
                            <div style="font-size: 16px; color: #ccc; margin: 10px 0;">High Score: ${highScore}</div>
                            <button onclick="resetGame()" style="
                                background: #4CAF50; 
                                color: white; 
                                border: none; 
                                padding: 15px 30px; 
                                font-size: 18px; 
                                border-radius: 5px; 
                                cursor: pointer;
                                margin-top: 20px;
                            ">Start New Game</button>
                        `;
                    }
                    gameOverElement.style.display = 'block';
                    
                    // Hide touch area when game is over
                    const touchArea = document.querySelector('.touch-area');
                    if (touchArea) {
                        touchArea.style.display = 'none';
                    }
                }
            }
        }
    });

    // Game over if invaders reach bottom
    invaders.forEach(inv => {
        if (inv.position.y < -30 && !gameOver) {
            gameOver = true;
            
            // Check for new high score
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('spaceInvadersHighScore', highScore);
                highScoreElement.textContent = `High Score: ${highScore}`;
                gameOverElement.innerHTML = `
                    <div>Game Over!</div>
                    <div style="font-size: 24px; margin: 10px 0;">Score: ${score}</div>
                    <div style="font-size: 20px; color: gold; margin: 10px 0;">NEW HIGH SCORE! üéâ</div>
                    <button onclick="resetGame()" style="
                        background: #4CAF50; 
                        color: white; 
                        border: none; 
                        padding: 15px 30px; 
                        font-size: 18px; 
                        border-radius: 5px; 
                        cursor: pointer;
                        margin-top: 20px;
                    ">Start New Game</button>
                `;
            } else {
                gameOverElement.innerHTML = `
                    <div>Game Over!</div>
                    <div style="font-size: 24px; margin: 10px 0;">Score: ${score}</div>
                    <div style="font-size: 16px; color: #ccc; margin: 10px 0;">High Score: ${highScore}</div>
                    <button onclick="resetGame()" style="
                        background: #4CAF50; 
                        color: white; 
                        border: none; 
                        padding: 15px 30px; 
                        font-size: 18px; 
                        border-radius: 5px; 
                        cursor: pointer;
                        margin-top: 20px;
                    ">Start New Game</button>
                `;
            }
            gameOverElement.style.display = 'block';
            
            // Hide touch area when game is over
            const touchArea = document.querySelector('.touch-area');
            if (touchArea) {
                touchArea.style.display = 'none';
            }
        }
    });

    // Enhanced invader animations with type-specific effects
    invaders.forEach((inv, index) => {
        const time = Date.now() * 0.001;
        
        // Basic movement
        inv.position.y -= 0.05 * wave;
        
        // Type-specific animations
        if (inv.userData.type === 'elite') {
            // Elite invaders: Complex rotation and ring spinning
            inv.children[0].rotation.y += 0.02;
            inv.children[0].rotation.x += 0.01;
            if (inv.userData.ring) {
                inv.userData.ring.rotation.z += 0.05;
                inv.userData.ring.material.emissiveIntensity = 0.4 + Math.sin(time * 4) * 0.2;
            }
            inv.children[0].scale.setScalar(1 + Math.sin(time * 3 + index * 0.5) * 0.15);
        } else if (inv.userData.type === 'standard') {
            // Standard invaders: Steady rotation with pulsing
            inv.children[0].rotation.y += 0.015;
            inv.children[0].rotation.z += 0.008;
            inv.children[0].scale.setScalar(1 + Math.sin(time * 2 + index * 0.3) * 0.1);
        } else {
            // Scout invaders: Fast, erratic movement
            inv.children[0].rotation.x += 0.025;
            inv.children[0].rotation.y += 0.02;
            inv.children[0].rotation.z += 0.015;
            inv.children[0].scale.setScalar(1 + Math.sin(time * 5 + index * 0.7) * 0.08);
            
            // Add slight horizontal wobble
            inv.position.x += Math.sin(time * 3 + index) * 0.02;
        }
        
        // Animate glow effect
        if (inv.userData.glow) {
            inv.userData.glow.material.opacity = 0.1 + Math.sin(time * 2 + index * 0.2) * 0.05;
            inv.userData.glow.scale.setScalar(1 + Math.sin(time * 1.5 + index * 0.1) * 0.1);
        }
        
        // Animate material emissive intensity
        if (inv.children[0].material.emissiveIntensity !== undefined) {
            const baseIntensity = inv.userData.type === 'elite' ? 0.8 : 
                                 inv.userData.type === 'standard' ? 0.6 : 0.4;
            inv.children[0].material.emissiveIntensity = baseIntensity + Math.sin(time * 2 + index * 0.3) * 0.2;
        }
    });

    // Animate stars with enhanced effects
    stars.forEach(starGroup => {
        // Slower, more graceful movement
        starGroup.position.z += 1.2;
        
        // Dynamic scaling for perspective effect
        const scale = 1 + (starGroup.position.z + 200) * 0.003;
        starGroup.scale.setScalar(scale);
        
        // Gentle rotation for dynamic effect
        starGroup.rotation.z += 0.01;
        
        // Animate star brightness
        const time = Date.now() * 0.001;
        const brightness = 0.8 + Math.sin(time * 2 + starGroup.position.x * 0.1) * 0.2;
        starGroup.children[0].material.emissiveIntensity = brightness;
        
        // Reset star when it passes the camera
        if (starGroup.position.z > 100) {
            starGroup.position.z = -300;
            starGroup.position.x = Math.random() * 300 - 150;
            starGroup.position.y = Math.random() * 300 - 150;
            starGroup.scale.setScalar(0.5);
            starGroup.rotation.z = 0;
        }
    });
    
    // Animate dynamic lighting
    if (window.gameData) {
        const time = Date.now() * 0.001;
        
        // Pulsing player light
        window.gameData.playerLight.intensity = 2 + Math.sin(time * 3) * 0.5;
        window.gameData.playerLight.position.x = ship.position.x;
        
        // Pulsing enemy light
        window.gameData.enemyLight.intensity = 1.5 + Math.sin(time * 2) * 0.3;
        
        // Rotating accent light
        window.gameData.accentLight.position.x = Math.cos(time * 0.5) * 30;
        window.gameData.accentLight.position.z = Math.sin(time * 0.5) * 20 + 20;
        window.gameData.accentLight.intensity = 1 + Math.sin(time * 4) * 0.3;
    }
    
    // Animate enhanced spaceship effects
    if (ship.userData) {
        const time = Date.now() * 0.001;
        
        // Animate dual engine glows
        if (ship.userData.leftGlow && ship.userData.rightGlow) {
            const intensity = 1.5 + Math.sin(time * 10) * 0.4;
            ship.userData.leftGlow.material.emissiveIntensity = intensity;
            ship.userData.rightGlow.material.emissiveIntensity = intensity;
            
            const scale = 1 + Math.sin(time * 8) * 0.15;
            ship.userData.leftGlow.scale.setScalar(scale);
            ship.userData.rightGlow.scale.setScalar(scale);
        }
        
        // Animate engine trails
        if (ship.userData.leftTrail && ship.userData.rightTrail) {
            const trailIntensity = 1.0 + Math.sin(time * 12) * 0.3;
            ship.userData.leftTrail.material.emissiveIntensity = trailIntensity;
            ship.userData.rightTrail.material.emissiveIntensity = trailIntensity;
            
            const trailScale = 1 + Math.sin(time * 15) * 0.1;
            ship.userData.leftTrail.scale.setScalar(trailScale);
            ship.userData.rightTrail.scale.setScalar(trailScale);
        }
        
        // Animate wing tip lights (navigation lights)
        if (ship.userData.leftTip && ship.userData.rightTip) {
            const leftIntensity = 1.0 + Math.sin(time * 4) * 0.5;
            const rightIntensity = 1.0 + Math.sin(time * 4 + Math.PI) * 0.5;
            ship.userData.leftTip.material.emissiveIntensity = leftIntensity;
            ship.userData.rightTip.material.emissiveIntensity = rightIntensity;
        }
        
        // Animate cockpit glow
        if (ship.userData.cockpit) {
            const cockpitIntensity = 0.7 + Math.sin(time * 3) * 0.2;
            ship.userData.cockpit.material.emissiveIntensity = cockpitIntensity;
        }
    }

    // SpaceX rocket spawning system
    rocketSpawnTimer++;
    if (rocketSpawnTimer >= rocketSpawnInterval && Math.random() < rocketSpawnChance && !gameOver) {
        createSpaceXRocket();
        rocketSpawnTimer = 0;
        // Reset spawn interval with some randomness
        rocketSpawnInterval = 200 + Math.random() * 400;
    }
    
    // Update SpaceX rockets
    spaceXRockets.forEach((rocket, index) => {
        if (rocket.userData.destroyed) return;
        
        // Move rocket horizontally
        rocket.position.x += rocket.userData.direction * rocket.userData.speed;
        
        // Add slight vertical bobbing
        const time = Date.now() * 0.001;
        rocket.position.y = rocket.userData.baseY + Math.sin(time * 2 + index) * 0.5;
        
        // Animate engine flames
        rocket.children.forEach((child, childIndex) => {
            if (childIndex >= 3 && childIndex < 12) { // Engine flames
                const flamePulse = 1 + Math.sin(time * 10 + childIndex) * 0.3;
                child.scale.setScalar(flamePulse);
                child.material.emissiveIntensity = 2.0 + Math.sin(time * 8 + childIndex) * 0.5;
            }
        });
        
        // Remove rocket when it goes off screen
        if (Math.abs(rocket.position.x) > 80) {
            scene.remove(rocket);
            spaceXRockets.splice(index, 1);
            console.log('SpaceX rocket removed (off-screen)');
        }
    });

    // Enhanced enemy bombing system
    if (Math.random() < 0.012) { // Slightly increased chance
        const randomInv = invaders[Math.floor(Math.random() * invaders.length)];
        if (randomInv) {
            const enemyBombGroup = new THREE.Group();
            
            // Different bomb types based on invader type - all made bigger
            let bombColor, glowColor, emissiveColor, bombSize;
            if (randomInv.userData.type === 'elite') {
                bombColor = 0x660000;
                glowColor = 0xff3300;
                emissiveColor = 0xff3300;
                bombSize = 0.8; // Increased from 0.4
            } else if (randomInv.userData.type === 'standard') {
                bombColor = 0x004466;
                glowColor = 0x00aaff;
                emissiveColor = 0x00ffff;
                bombSize = 0.7; // Increased from 0.3
            } else {
                bombColor = 0x004400;
                glowColor = 0x00ff88;
                emissiveColor = 0x00ff88;
                bombSize = 0.6; // Increased from 0.25
            }
            
            // Main bomb body (spherical with metallic surface)
            const bombGeometry = new THREE.SphereGeometry(bombSize, 16, 16);
            const bombMaterial = new THREE.MeshPhysicalMaterial({
                color: bombColor,
                metalness: 0.9,
                roughness: 0.2,
                emissive: emissiveColor,
                emissiveIntensity: 0.8,
                transparent: true,
                opacity: 0.95
            });
            const bomb = new THREE.Mesh(bombGeometry, bombMaterial);
            bomb.castShadow = true;
            enemyBombGroup.add(bomb);
            
            // Add bomb fins/stabilizers - bigger to match bomb size
            const finGeometry = new THREE.BoxGeometry(bombSize * 2.0, 0.08, bombSize * 1.2);
            const finMaterial = new THREE.MeshPhysicalMaterial({
                color: bombColor,
                metalness: 0.8,
                roughness: 0.3,
                emissive: emissiveColor,
                emissiveIntensity: 0.6
            });
            
            // Create cross-shaped fins
            for (let i = 0; i < 2; i++) {
                const fin = new THREE.Mesh(finGeometry, finMaterial);
                fin.rotation.z = (i * Math.PI) / 2;
                fin.position.y = -bombSize * 0.5;
                fin.castShadow = true;
                enemyBombGroup.add(fin);
            }
            
            // Energy core glow - bigger and brighter
            const coreGeometry = new THREE.SphereGeometry(bombSize * 0.7, 16, 16);
            const coreMaterial = new THREE.MeshBasicMaterial({
                color: glowColor,
                transparent: true,
                opacity: 0.8,
                emissive: emissiveColor,
                emissiveIntensity: 2.0
            });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            enemyBombGroup.add(core);
            
            // Outer energy field - bigger and more visible
            const fieldGeometry = new THREE.SphereGeometry(bombSize * 2.2, 20, 20);
            const fieldMaterial = new THREE.MeshBasicMaterial({
                color: glowColor,
                transparent: true,
                opacity: 0.3,
                emissive: emissiveColor,
                emissiveIntensity: 1.2,
                side: THREE.BackSide
            });
            const field = new THREE.Mesh(fieldGeometry, fieldMaterial);
            enemyBombGroup.add(field);
            
            // Add energy sparks around the bomb - bigger and more numerous
            const sparkParticles = [];
            for (let i = 0; i < 8; i++) {
                const sparkGeometry = new THREE.SphereGeometry(0.08, 8, 8);
                const sparkMaterial = new THREE.MeshBasicMaterial({
                    color: glowColor,
                    transparent: true,
                    opacity: 0.9,
                    emissive: emissiveColor,
                    emissiveIntensity: 1.5
                });
                const spark = new THREE.Mesh(sparkGeometry, sparkMaterial);
                const angle = (i / 8) * Math.PI * 2;
                spark.position.set(
                    Math.cos(angle) * bombSize * 2.5,
                    Math.sin(angle) * bombSize * 2.5,
                    (Math.random() - 0.5) * bombSize
                );
                sparkParticles.push(spark);
                enemyBombGroup.add(spark);
            }
            
            enemyBombGroup.position.set(randomInv.position.x, randomInv.position.y - 5, 0);
            enemyBombGroup.userData = { 
                type: 'enemy',
                core,
                field,
                sparkParticles,
                bombSize,
                spinSpeed: 0.02,
                sparkOrbitSpeed: 0.05
            };
            scene.add(enemyBombGroup);
            projectiles.push({ mesh: enemyBombGroup, direction: -1 });
        }
    }
    
    // Enhanced explosion animations
    for (let i = explosions.length - 1; i >= 0; i--) {
        const group = explosions[i];
        group.userData.life += 1;
        
        group.children.forEach((particle, index) => {
            // Check if it's the shockwave ring (usually the last child)
            if (particle.userData.expansionSpeed) {
                // Animate shockwave ring
                const currentScale = particle.scale.x;
                if (currentScale < particle.userData.maxScale) {
                    particle.scale.setScalar(currentScale + particle.userData.expansionSpeed);
                }
                particle.material.opacity -= particle.userData.decay;
                particle.rotation.z += 0.1;
            } else {
                // Animate regular particles
                particle.position.x += particle.userData.vx;
                particle.position.y += particle.userData.vy;
                particle.position.z += particle.userData.vz;
                
                // Add rotation
                if (particle.userData.rotationSpeed) {
                    particle.rotation.x += particle.userData.rotationSpeed;
                    particle.rotation.y += particle.userData.rotationSpeed * 0.7;
                    particle.rotation.z += particle.userData.rotationSpeed * 0.5;
                }
                
                // Fade out
                particle.material.opacity -= particle.userData.decay;
                
                // Gradually reduce emissive intensity
                if (particle.material.emissiveIntensity > 0) {
                    particle.material.emissiveIntensity -= particle.userData.decay * 0.5;
                }
                
                // Add gravity effect to particles
                particle.userData.vy -= 0.02;
                
                // Scale down over time
                const scaleReduction = particle.userData.decay * 0.3;
                particle.scale.multiplyScalar(1 - scaleReduction);
            }
        });
        
        // Remove explosion when particles are too faded or too old
        if (group.userData.life > 60 || group.children.every(p => p.material.opacity <= 0)) {
            scene.remove(group);
            explosions.splice(i, 1);
        }
    }
    
    renderer.render(scene, camera); // Draw the scene
}

// Enhanced explosion effect with bomb-specific impacts
function createExplosion(x, y, z, type = 'default') {
    const explosionGroup = new THREE.Group();
    
    // Determine explosion characteristics based on type
    let mainParticleCount, sparkCount, shockwaveColor, particleColors, intensity;
    
    if (type === 'bomb_impact') {
        // Missile hitting invader - minimized explosion
        mainParticleCount = 15;
        sparkCount = 8;
        shockwaveColor = 0xff6600;
        particleColors = {
            hueRange: [15, 45], // Orange to yellow
            saturation: 90,
            lightness: [40, 70]
        };
        intensity = 0.6;
    } else if (type === 'bomb_ship') {
        // Bomb hitting player ship - minimized explosion
        mainParticleCount = 25;
        sparkCount = 15;
        shockwaveColor = 0xff2200;
        particleColors = {
            hueRange: [0, 30], // Red to orange
            saturation: 100,
            lightness: [50, 80]
        };
        intensity = 0.8;
    } else if (type === 'rocket_hit') {
        // Small explosion when hitting SpaceX rocket
        mainParticleCount = 10;
        sparkCount = 5;
        shockwaveColor = 0xffffff;
        particleColors = {
            hueRange: [200, 240], // Blue to white
            saturation: 50,
            lightness: [60, 90]
        };
        intensity = 0.4;
    } else if (type === 'rocket_destroyed') {
        // Explosion when SpaceX rocket is destroyed - minimized
        mainParticleCount = 40;
        sparkCount = 20;
        shockwaveColor = 0x00aaff;
        particleColors = {
            hueRange: [180, 220], // Blue to cyan
            saturation: 80,
            lightness: [40, 80]
        };
        intensity = 1.0;
    } else {
        // Default explosion - minimized
        mainParticleCount = 12;
        sparkCount = 6;
        shockwaveColor = 0xffff00;
        particleColors = {
            hueRange: [20, 60],
            saturation: 80,
            lightness: [50, 70]
        };
        intensity = 0.5;
    }
    
    // Main explosion particles (debris and fire)
    for (let i = 0; i < mainParticleCount; i++) {
        const geometry = new THREE.SphereGeometry(0.2 + Math.random() * 0.6, 8, 8);
        const hue = particleColors.hueRange[0] + Math.random() * (particleColors.hueRange[1] - particleColors.hueRange[0]);
        const sat = particleColors.saturation;
        const light = particleColors.lightness[0] + Math.random() * (particleColors.lightness[1] - particleColors.lightness[0]);
        const color = new THREE.Color(`hsl(${hue}, ${sat}%, ${light}%)`);
        
        const material = new THREE.MeshBasicMaterial({ 
            color, 
            transparent: true, 
            opacity: 1,
            emissive: color,
            emissiveIntensity: 0.8 * intensity
        });
        const particle = new THREE.Mesh(geometry, material);
        
        // More realistic explosion physics
        const theta = Math.random() * 2 * Math.PI;
        const phi = Math.random() * Math.PI;
        const speed = (2 + Math.random() * 4) * intensity;
        particle.userData = {
            vx: Math.sin(phi) * Math.cos(theta) * speed,
            vy: Math.sin(phi) * Math.sin(theta) * speed,
            vz: Math.cos(phi) * speed,
            decay: 0.012 + Math.random() * 0.018,
            rotationSpeed: (Math.random() - 0.5) * 0.3 * intensity,
            initialSize: particle.scale.x
        };
        particle.position.set(x, y, z);
        explosionGroup.add(particle);
    }
    
    // Metal debris particles (for bomb impacts)
    if (type.includes('bomb')) {
        for (let i = 0; i < 15; i++) {
            const debrisGeometry = new THREE.BoxGeometry(
                0.1 + Math.random() * 0.3,
                0.1 + Math.random() * 0.3,
                0.1 + Math.random() * 0.3
            );
            const debrisMaterial = new THREE.MeshBasicMaterial({
                color: 0x666666,
                transparent: true,
                opacity: 1,
                emissive: 0x333333,
                emissiveIntensity: 0.5
            });
            const debris = new THREE.Mesh(debrisGeometry, debrisMaterial);
            
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.random() * Math.PI;
            const speed = (1 + Math.random() * 3) * intensity;
            debris.userData = {
                vx: Math.sin(phi) * Math.cos(theta) * speed,
                vy: Math.sin(phi) * Math.sin(theta) * speed,
                vz: Math.cos(phi) * speed,
                decay: 0.008 + Math.random() * 0.012,
                rotationSpeed: (Math.random() - 0.5) * 0.4
            };
            debris.position.set(x, y, z);
            explosionGroup.add(debris);
        }
    }
    
    // Bright spark particles
    for (let i = 0; i < sparkCount; i++) {
        const geometry = new THREE.SphereGeometry(0.08 + Math.random() * 0.12, 6, 6);
        const color = new THREE.Color(0xffffff);
        const material = new THREE.MeshBasicMaterial({ 
            color, 
            transparent: true, 
            opacity: 1,
            emissive: color,
            emissiveIntensity: 1.5 * intensity
        });
        const spark = new THREE.Mesh(geometry, material);
        
        const theta = Math.random() * 2 * Math.PI;
        const phi = Math.random() * Math.PI;
        const speed = (4 + Math.random() * 5) * intensity;
        spark.userData = {
            vx: Math.sin(phi) * Math.cos(theta) * speed,
            vy: Math.sin(phi) * Math.sin(theta) * speed,
            vz: Math.cos(phi) * speed,
            decay: 0.04 + Math.random() * 0.03,
            rotationSpeed: (Math.random() - 0.5) * 0.5
        };
        spark.position.set(x, y, z);
        explosionGroup.add(spark);
    }
    
    // Enhanced shockwave ring
    const ringGeometry = new THREE.RingGeometry(0.2, 0.8, 24);
    const ringMaterial = new THREE.MeshBasicMaterial({
        color: shockwaveColor,
        transparent: true,
        opacity: 0.9,
        emissive: shockwaveColor,
        emissiveIntensity: 1.5 * intensity,
        side: THREE.DoubleSide
    });
    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
    ring.position.set(x, y, z);
    ring.userData = {
        expansionSpeed: 0.4 * intensity,
        decay: 0.04,
        maxScale: 12 * intensity
    };
    explosionGroup.add(ring);
    
    // Add secondary shockwave for bomb impacts
    if (type.includes('bomb')) {
        const secondaryRingGeometry = new THREE.RingGeometry(0.1, 0.4, 16);
        const secondaryRingMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.6,
            emissive: 0xffffff,
            emissiveIntensity: 2.0,
            side: THREE.DoubleSide
        });
        const secondaryRing = new THREE.Mesh(secondaryRingGeometry, secondaryRingMaterial);
        secondaryRing.position.set(x, y, z);
        secondaryRing.userData = {
            expansionSpeed: 0.6 * intensity,
            decay: 0.06,
            maxScale: 8 * intensity
        };
        explosionGroup.add(secondaryRing);
    }
    
    scene.add(explosionGroup);
    explosionGroup.userData = { life: 0, type };
    explosions.push(explosionGroup);
}

let explosions = [];

// SpaceX Rocket creation function
function createSpaceXRocket() {
    const rocketGroup = new THREE.Group();
    
    // Main rocket body (Falcon 9 style)
    const bodyGeometry = new THREE.CylinderGeometry(0.6, 0.8, 12, 16);
    const bodyMaterial = new THREE.MeshPhysicalMaterial({
        color: 0xeeeeee,
        metalness: 0.8,
        roughness: 0.2,
        emissive: 0x222222,
        emissiveIntensity: 0.3
    });
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    body.castShadow = true;
    rocketGroup.add(body);
    
    // Nose cone
    const noseGeometry = new THREE.ConeGeometry(0.6, 2, 16);
    const noseMaterial = new THREE.MeshPhysicalMaterial({
        color: 0xdddddd,
        metalness: 0.9,
        roughness: 0.1,
        emissive: 0x111111,
        emissiveIntensity: 0.2
    });
    const nose = new THREE.Mesh(noseGeometry, noseMaterial);
    nose.position.y = 7;
    nose.castShadow = true;
    rocketGroup.add(nose);
    
    // Engine section
    const engineGeometry = new THREE.CylinderGeometry(0.8, 1.2, 3, 16);
    const engineMaterial = new THREE.MeshPhysicalMaterial({
        color: 0x333333,
        metalness: 1.0,
        roughness: 0.3,
        emissive: 0x001122,
        emissiveIntensity: 0.5
    });
    const engine = new THREE.Mesh(engineGeometry, engineMaterial);
    engine.position.y = -7.5;
    engine.castShadow = true;
    rocketGroup.add(engine);
    
    // Engine flames
    for (let i = 0; i < 9; i++) {
        const flameGeometry = new THREE.ConeGeometry(0.15, 2 + Math.random() * 1, 8);
        const flameMaterial = new THREE.MeshBasicMaterial({
            color: new THREE.Color().setHSL(0.1 - i * 0.02, 1, 0.6),
            transparent: true,
            opacity: 0.8,
            emissive: new THREE.Color().setHSL(0.1 - i * 0.02, 1, 0.8),
            emissiveIntensity: 2.0
        });
        const flame = new THREE.Mesh(flameGeometry, flameMaterial);
        const angle = (i / 9) * Math.PI * 2;
        flame.position.set(
            Math.cos(angle) * 0.4,
            -10 - Math.random() * 1,
            Math.sin(angle) * 0.4
        );
        flame.rotation.x = Math.PI;
        rocketGroup.add(flame);
    }
    
    // Landing legs
    for (let i = 0; i < 4; i++) {
        const legGeometry = new THREE.BoxGeometry(0.1, 2, 0.1);
        const legMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x666666,
            metalness: 0.8,
            roughness: 0.4
        });
        const leg = new THREE.Mesh(legGeometry, legMaterial);
        const angle = (i / 4) * Math.PI * 2;
        leg.position.set(
            Math.cos(angle) * 1.0,
            -5,
            Math.sin(angle) * 1.0
        );
        leg.rotation.z = Math.cos(angle) * 0.3;
        leg.rotation.x = Math.sin(angle) * 0.3;
        leg.castShadow = true;
        rocketGroup.add(leg);
    }
    
    // SpaceX logo area (black band)
    const logoGeometry = new THREE.CylinderGeometry(0.61, 0.61, 1, 16);
    const logoMaterial = new THREE.MeshPhysicalMaterial({
        color: 0x000000,
        metalness: 0.5,
        roughness: 0.8
    });
    const logo = new THREE.Mesh(logoGeometry, logoMaterial);
    logo.position.y = 2;
    rocketGroup.add(logo);
    
    // Grid fins
    for (let i = 0; i < 4; i++) {
        const finGeometry = new THREE.BoxGeometry(1.5, 0.1, 1);
        const finMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x444444,
            metalness: 0.9,
            roughness: 0.2
        });
        const fin = new THREE.Mesh(finGeometry, finMaterial);
        const angle = (i / 4) * Math.PI * 2;
        fin.position.set(
            Math.cos(angle) * 1.2,
            -2,
            Math.sin(angle) * 1.2
        );
        fin.rotation.y = angle;
        fin.castShadow = true;
        rocketGroup.add(fin);
    }
    
    // Position rocket randomly
    const side = Math.random() < 0.5 ? -1 : 1;
    rocketGroup.position.set(side * 60, Math.random() * 20 - 10, 0);
    rocketGroup.rotation.z = side * 0.2; // Slight tilt
    
    // Movement properties
    rocketGroup.userData = {
        type: 'spacex',
        direction: -side,
        speed: 0.8 + Math.random() * 0.4,
        hitCount: 0,
        maxHits: 10,
        destroyed: false,
        baseY: rocketGroup.position.y
    };
    
    scene.add(rocketGroup);
    spaceXRockets.push(rocketGroup);
    
    console.log('SpaceX rocket spawned!');
}

// Start the game
init();
    </script>
</body>
</html> 